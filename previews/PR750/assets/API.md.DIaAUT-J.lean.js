import{_ as e,c as t,o as l,a7 as s,j as i,a}from"./chunks/framework.B5nwnvfY.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"API.md","filePath":"API.md","lastUpdated":null}'),n={name:"API.md"},d=s("",102),r=i("div",{style:{"border-width":"1px","border-style":"solid","border-color":"black",padding:"1em","border-radius":"25px"}},[i("a",{id:"ClimaLand.auxiliary_types-Tuple{AbstractModel}",href:"#ClimaLand.auxiliary_types-Tuple{AbstractModel}"},"#"),a(" "),i("b",null,[i("u",null,"ClimaLand.auxiliary_types")]),a(" — "),i("i",null,"Method"),a(". "),i("p",{FT:""},"auxiliary_types(m::AbstractModel{FT}) where"),i("p",null,"Returns the auxiliary variable types for the model in the form of a tuple."),i("p",null,[a("Types provided must have "),i("code",null,"ClimaCore.RecursiveApply.rzero(T::DataType)"),a(" defined. Common examples include")]),i("ul",null,[i("li",null,"Float64, Float32 for scalar variables (a scalar value at each")]),i("p",null,"coordinate point)"),i("ul",null,[i("li",null,"SVector{k,Float64} for a mutable but statically sized array of")]),i("p",null,[a("length "),i("code",null,"k"),a(" at each coordinate point.")]),i("ul",null,[i("li",null,"Note that Arrays, MVectors are not isbits and cannot be used.")]),i("p",null,"Here, the coordinate points are those returned by coordinates(model)."),i("p",null,[i("a",{href:"https://github.com/CliMA/ClimaLand.jl",target:"_blank",rel:"noreferrer"},"source")])],-1),p=s("",127),h=i("div",{style:{"border-width":"1px","border-style":"solid","border-color":"black",padding:"1em","border-radius":"25px"}},[i("a",{id:"ClimaLand.prognostic_types-Tuple{AbstractModel}",href:"#ClimaLand.prognostic_types-Tuple{AbstractModel}"},"#"),a(" "),i("b",null,[i("u",null,"ClimaLand.prognostic_types")]),a(" — "),i("i",null,"Method"),a(". "),i("p",{FT:""},"prognostic_types(m::AbstractModel{FT}) where"),i("p",null,"Returns the prognostic variable types for the model in the form of a tuple."),i("p",null,[a("Types provided must have "),i("code",null,"ClimaCore.RecursiveApply.rzero(T::DataType)"),a(" defined. Common examples include")]),i("ul",null,[i("li",null,"Float64, Float32 for scalar variables (a scalar value at each")]),i("p",null,"coordinate point)"),i("ul",null,[i("li",null,"SVector{k,Float64} for a mutable but statically sized array of")]),i("p",null,[a("length "),i("code",null,"k"),a(" at each coordinate point.")]),i("p",null,"Here, the coordinate points are those returned by coordinates(model)."),i("p",null,"Note that this default suggests that a model has no prognostic variables, which is an invalid model setup. This function is meant to be extended for all models."),i("p",null,[i("a",{href:"https://github.com/CliMA/ClimaLand.jl",target:"_blank",rel:"noreferrer"},"source")])],-1),o=s("",43),c=[d,r,p,h,o];function k(u,b,g,y,m,E){return l(),t("div",null,c)}const f=e(n,[["render",k]]);export{F as __pageData,f as default};
